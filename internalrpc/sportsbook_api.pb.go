// Code generated by protoc-gen-go. DO NOT EDIT.
// source: internalrpc/sportsbook_api.proto

package internalrpc

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "google.golang.org/genproto/googleapis/api/annotations"
import google_protobuf1 "github.com/golang/protobuf/ptypes/empty"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type PlayerTags int32

const (
	PlayerTags_DEFAULT PlayerTags = 0
	PlayerTags_ADMIN   PlayerTags = 1
	PlayerTags_VIP     PlayerTags = 2
)

var PlayerTags_name = map[int32]string{
	0: "DEFAULT",
	1: "ADMIN",
	2: "VIP",
}
var PlayerTags_value = map[string]int32{
	"DEFAULT": 0,
	"ADMIN":   1,
	"VIP":     2,
}

func (x PlayerTags) String() string {
	return proto.EnumName(PlayerTags_name, int32(x))
}
func (PlayerTags) EnumDescriptor() ([]byte, []int) { return fileDescriptor14, []int{0} }

type PlayerRequest struct {
	Id uint32 `protobuf:"varint,1,opt,name=id" json:"id,omitempty"`
}

func (m *PlayerRequest) Reset()                    { *m = PlayerRequest{} }
func (m *PlayerRequest) String() string            { return proto.CompactTextString(m) }
func (*PlayerRequest) ProtoMessage()               {}
func (*PlayerRequest) Descriptor() ([]byte, []int) { return fileDescriptor14, []int{0} }

func (m *PlayerRequest) GetId() uint32 {
	if m != nil {
		return m.Id
	}
	return 0
}

type PlayerReply struct {
	Tags []PlayerTags `protobuf:"varint,1,rep,packed,name=tags,enum=internalrpc.PlayerTags" json:"tags,omitempty"`
	// please use the string value of SportsEntityTypes enum as input
	RestrictedSportEntities map[string]*RestrictedIDs `protobuf:"bytes,2,rep,name=restricted_sport_entities,json=restrictedSportEntities" json:"restricted_sport_entities,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *PlayerReply) Reset()                    { *m = PlayerReply{} }
func (m *PlayerReply) String() string            { return proto.CompactTextString(m) }
func (*PlayerReply) ProtoMessage()               {}
func (*PlayerReply) Descriptor() ([]byte, []int) { return fileDescriptor14, []int{1} }

func (m *PlayerReply) GetTags() []PlayerTags {
	if m != nil {
		return m.Tags
	}
	return nil
}

func (m *PlayerReply) GetRestrictedSportEntities() map[string]*RestrictedIDs {
	if m != nil {
		return m.RestrictedSportEntities
	}
	return nil
}

type RestrictedIDs struct {
	Value []uint32 `protobuf:"varint,1,rep,packed,name=value" json:"value,omitempty"`
}

func (m *RestrictedIDs) Reset()                    { *m = RestrictedIDs{} }
func (m *RestrictedIDs) String() string            { return proto.CompactTextString(m) }
func (*RestrictedIDs) ProtoMessage()               {}
func (*RestrictedIDs) Descriptor() ([]byte, []int) { return fileDescriptor14, []int{2} }

func (m *RestrictedIDs) GetValue() []uint32 {
	if m != nil {
		return m.Value
	}
	return nil
}

func init() {
	proto.RegisterType((*PlayerRequest)(nil), "internalrpc.PlayerRequest")
	proto.RegisterType((*PlayerReply)(nil), "internalrpc.PlayerReply")
	proto.RegisterType((*RestrictedIDs)(nil), "internalrpc.RestrictedIDs")
	proto.RegisterEnum("internalrpc.PlayerTags", PlayerTags_name, PlayerTags_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for SportsbookAPI service

type SportsbookAPIClient interface {
	GetPlayerInfo(ctx context.Context, in *PlayerRequest, opts ...grpc.CallOption) (*PlayerReply, error)
	// Get Status of selection according to all locking status
	//
	// For selection in API and place bet checking
	GetOverrideSelectionStatus(ctx context.Context, in *OverrideSelectionStatusRequest, opts ...grpc.CallOption) (*OverrideSelectionStatusReply, error)
	// Get Status of Locking for Provider and Manual Override
	//
	// No input required
	GetFullLockingStatus(ctx context.Context, in *google_protobuf1.Empty, opts ...grpc.CallOption) (*FullLockingStatusReply, error)
	// Set Status of Locking for Manual Override
	//
	// Status_value mapping input should be:
	// from ["betradar_lcoo", "betradar_live", "pinnacle", "prematch", "live", "global"]
	// to ENABLED or TEMPORARY_DISABLED
	SetLockingStatus(ctx context.Context, in *SetLockingStatusRequest, opts ...grpc.CallOption) (*google_protobuf1.Empty, error)
}

type sportsbookAPIClient struct {
	cc *grpc.ClientConn
}

func NewSportsbookAPIClient(cc *grpc.ClientConn) SportsbookAPIClient {
	return &sportsbookAPIClient{cc}
}

func (c *sportsbookAPIClient) GetPlayerInfo(ctx context.Context, in *PlayerRequest, opts ...grpc.CallOption) (*PlayerReply, error) {
	out := new(PlayerReply)
	err := grpc.Invoke(ctx, "/internalrpc.SportsbookAPI/GetPlayerInfo", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sportsbookAPIClient) GetOverrideSelectionStatus(ctx context.Context, in *OverrideSelectionStatusRequest, opts ...grpc.CallOption) (*OverrideSelectionStatusReply, error) {
	out := new(OverrideSelectionStatusReply)
	err := grpc.Invoke(ctx, "/internalrpc.SportsbookAPI/GetOverrideSelectionStatus", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sportsbookAPIClient) GetFullLockingStatus(ctx context.Context, in *google_protobuf1.Empty, opts ...grpc.CallOption) (*FullLockingStatusReply, error) {
	out := new(FullLockingStatusReply)
	err := grpc.Invoke(ctx, "/internalrpc.SportsbookAPI/GetFullLockingStatus", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sportsbookAPIClient) SetLockingStatus(ctx context.Context, in *SetLockingStatusRequest, opts ...grpc.CallOption) (*google_protobuf1.Empty, error) {
	out := new(google_protobuf1.Empty)
	err := grpc.Invoke(ctx, "/internalrpc.SportsbookAPI/SetLockingStatus", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for SportsbookAPI service

type SportsbookAPIServer interface {
	GetPlayerInfo(context.Context, *PlayerRequest) (*PlayerReply, error)
	// Get Status of selection according to all locking status
	//
	// For selection in API and place bet checking
	GetOverrideSelectionStatus(context.Context, *OverrideSelectionStatusRequest) (*OverrideSelectionStatusReply, error)
	// Get Status of Locking for Provider and Manual Override
	//
	// No input required
	GetFullLockingStatus(context.Context, *google_protobuf1.Empty) (*FullLockingStatusReply, error)
	// Set Status of Locking for Manual Override
	//
	// Status_value mapping input should be:
	// from ["betradar_lcoo", "betradar_live", "pinnacle", "prematch", "live", "global"]
	// to ENABLED or TEMPORARY_DISABLED
	SetLockingStatus(context.Context, *SetLockingStatusRequest) (*google_protobuf1.Empty, error)
}

func RegisterSportsbookAPIServer(s *grpc.Server, srv SportsbookAPIServer) {
	s.RegisterService(&_SportsbookAPI_serviceDesc, srv)
}

func _SportsbookAPI_GetPlayerInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PlayerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SportsbookAPIServer).GetPlayerInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/internalrpc.SportsbookAPI/GetPlayerInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SportsbookAPIServer).GetPlayerInfo(ctx, req.(*PlayerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SportsbookAPI_GetOverrideSelectionStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OverrideSelectionStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SportsbookAPIServer).GetOverrideSelectionStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/internalrpc.SportsbookAPI/GetOverrideSelectionStatus",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SportsbookAPIServer).GetOverrideSelectionStatus(ctx, req.(*OverrideSelectionStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SportsbookAPI_GetFullLockingStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(google_protobuf1.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SportsbookAPIServer).GetFullLockingStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/internalrpc.SportsbookAPI/GetFullLockingStatus",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SportsbookAPIServer).GetFullLockingStatus(ctx, req.(*google_protobuf1.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _SportsbookAPI_SetLockingStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetLockingStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SportsbookAPIServer).SetLockingStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/internalrpc.SportsbookAPI/SetLockingStatus",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SportsbookAPIServer).SetLockingStatus(ctx, req.(*SetLockingStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _SportsbookAPI_serviceDesc = grpc.ServiceDesc{
	ServiceName: "internalrpc.SportsbookAPI",
	HandlerType: (*SportsbookAPIServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetPlayerInfo",
			Handler:    _SportsbookAPI_GetPlayerInfo_Handler,
		},
		{
			MethodName: "GetOverrideSelectionStatus",
			Handler:    _SportsbookAPI_GetOverrideSelectionStatus_Handler,
		},
		{
			MethodName: "GetFullLockingStatus",
			Handler:    _SportsbookAPI_GetFullLockingStatus_Handler,
		},
		{
			MethodName: "SetLockingStatus",
			Handler:    _SportsbookAPI_SetLockingStatus_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "internalrpc/sportsbook_api.proto",
}

func init() { proto.RegisterFile("internalrpc/sportsbook_api.proto", fileDescriptor14) }

var fileDescriptor14 = []byte{
	// 522 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x8c, 0x93, 0x51, 0x6f, 0xd2, 0x50,
	0x14, 0xc7, 0xd7, 0xe2, 0x5c, 0x76, 0x48, 0x17, 0x72, 0xb3, 0x38, 0xec, 0x66, 0x86, 0x75, 0x46,
	0xdc, 0x62, 0xab, 0x18, 0x13, 0xb3, 0x37, 0x0c, 0x8c, 0x90, 0x4c, 0x25, 0x65, 0xfa, 0x4a, 0x2e,
	0x70, 0x68, 0x6e, 0x28, 0xbd, 0xdd, 0xbd, 0x07, 0x12, 0x92, 0x3d, 0xf9, 0x15, 0x8c, 0xdf, 0xca,
	0x37, 0xbf, 0x82, 0x1f, 0xc4, 0xd0, 0xd2, 0x8d, 0x2a, 0xa8, 0x6f, 0x6d, 0xce, 0xff, 0xff, 0xff,
	0x9d, 0x7b, 0xee, 0xb9, 0x50, 0x11, 0x11, 0xa1, 0x8a, 0x78, 0xa8, 0xe2, 0x81, 0xa7, 0x63, 0xa9,
	0x48, 0xf7, 0xa5, 0x1c, 0xf7, 0x78, 0x2c, 0xdc, 0x58, 0x49, 0x92, 0xac, 0xb8, 0xa2, 0xb0, 0x8f,
	0x02, 0x29, 0x83, 0x10, 0x3d, 0x1e, 0x0b, 0x8f, 0x47, 0x91, 0x24, 0x4e, 0x42, 0x46, 0x3a, 0x95,
	0xda, 0x87, 0xcb, 0x6a, 0xf2, 0xd7, 0x9f, 0x8e, 0x3c, 0x9c, 0xc4, 0x34, 0x5f, 0x16, 0x4f, 0x36,
	0x90, 0x26, 0x32, 0x12, 0x24, 0x55, 0xaa, 0x72, 0x8e, 0xc1, 0xea, 0x84, 0x7c, 0x8e, 0xca, 0xc7,
	0xeb, 0x29, 0x6a, 0x62, 0x7b, 0x60, 0x8a, 0x61, 0xd9, 0xa8, 0x18, 0x55, 0xcb, 0x37, 0xc5, 0xd0,
	0xf9, 0x66, 0x42, 0x31, 0x53, 0xc4, 0xe1, 0x9c, 0x9d, 0xc1, 0x3d, 0xe2, 0x81, 0x2e, 0x1b, 0x95,
	0x42, 0x75, 0xaf, 0x76, 0xe0, 0xae, 0x50, 0xdc, 0x54, 0x77, 0xc5, 0x03, 0xed, 0x27, 0x22, 0x76,
	0x0d, 0x0f, 0x15, 0x6a, 0x52, 0x62, 0x40, 0x38, 0xec, 0x25, 0x4d, 0xf4, 0x30, 0x22, 0x41, 0x02,
	0x75, 0xd9, 0xac, 0x14, 0xaa, 0xc5, 0xda, 0x9b, 0x35, 0x09, 0x09, 0xc9, 0xf5, 0x6f, 0x9d, 0xdd,
	0x85, 0xb1, 0xb9, 0xf4, 0x35, 0x23, 0x52, 0x73, 0xff, 0x40, 0xad, 0xaf, 0xda, 0x23, 0x38, 0xfa,
	0x9b, 0x91, 0x95, 0xa0, 0x30, 0xc6, 0x79, 0x72, 0xc0, 0x5d, 0x7f, 0xf1, 0xc9, 0x5e, 0xc2, 0xf6,
	0x8c, 0x87, 0x53, 0x2c, 0x9b, 0x15, 0xa3, 0x5a, 0xac, 0xd9, 0xb9, 0x86, 0xee, 0xb2, 0xda, 0x0d,
	0xed, 0xa7, 0xc2, 0x73, 0xf3, 0xad, 0xe1, 0x3c, 0x05, 0x2b, 0x57, 0x63, 0xfb, 0x59, 0xcc, 0x62,
	0x32, 0xd6, 0x52, 0x7a, 0xfa, 0x02, 0xe0, 0x6e, 0x2a, 0xac, 0x08, 0x3b, 0x8d, 0xe6, 0x45, 0xfd,
	0xd3, 0xe5, 0x55, 0x69, 0x8b, 0xed, 0xc2, 0x76, 0xbd, 0xf1, 0xbe, 0xfd, 0xa1, 0x64, 0xb0, 0x1d,
	0x28, 0x7c, 0x6e, 0x77, 0x4a, 0x66, 0xed, 0x7b, 0x01, 0xac, 0xee, 0xed, 0x5d, 0xd5, 0x3b, 0x6d,
	0xd6, 0x02, 0xab, 0x85, 0x94, 0x66, 0xb4, 0xa3, 0x91, 0x64, 0xf6, 0xda, 0x81, 0x25, 0x97, 0x67,
	0x97, 0x37, 0x0d, 0xd3, 0xd9, 0x62, 0x33, 0xb0, 0x5b, 0x48, 0x1f, 0x67, 0xa8, 0x94, 0x18, 0x62,
	0x17, 0x43, 0x1c, 0x2c, 0x76, 0xa9, 0x4b, 0x9c, 0xa6, 0x9a, 0x9d, 0xe5, 0x9c, 0x1b, 0x54, 0x19,
	0xe6, 0xf9, 0xff, 0x89, 0x53, 0xee, 0x0d, 0xec, 0xb7, 0x90, 0x2e, 0xa6, 0x61, 0x78, 0x29, 0x07,
	0x63, 0x11, 0x05, 0x4b, 0xe2, 0x03, 0x37, 0xdd, 0x5e, 0x37, 0xdb, 0x5e, 0xb7, 0xb9, 0xd8, 0x5e,
	0xfb, 0x49, 0x2e, 0xfc, 0x0f, 0x5f, 0x1a, 0xfb, 0xec, 0xcb, 0x8f, 0x9f, 0x5f, 0xcd, 0xc7, 0xec,
	0x38, 0x79, 0x19, 0x99, 0xc1, 0x9b, 0xbd, 0xf2, 0xc2, 0x54, 0xdc, 0xd3, 0x29, 0xe5, 0x06, 0x4a,
	0x5d, 0xa4, 0x3c, 0xf9, 0x24, 0x47, 0xf8, 0xbd, 0x9c, 0x1d, 0x72, 0x43, 0x7f, 0xce, 0x69, 0x82,
	0x3e, 0x71, 0xfe, 0x85, 0x3e, 0x37, 0x4e, 0xdf, 0x3d, 0x82, 0xc3, 0x81, 0x9c, 0xb8, 0x7d, 0x41,
	0x01, 0x9f, 0x60, 0xc8, 0xfb, 0x7a, 0x15, 0xdd, 0xbf, 0x9f, 0x44, 0xbf, 0xfe, 0x15, 0x00, 0x00,
	0xff, 0xff, 0x17, 0x30, 0x46, 0x6a, 0x15, 0x04, 0x00, 0x00,
}
