// Code generated by protoc-gen-go. DO NOT EDIT.
// source: internalrpc/sportsbook_monitor.proto

package internalrpc

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import google_protobuf1 "github.com/golang/protobuf/ptypes/empty"
import api "github.com/bitgaming/go-protobuf-schema/sportsbook/api"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type SetLockingStatusRequest struct {
	StatusValue map[string]api.SelectionStatus `protobuf:"bytes,1,rep,name=status_value,json=statusValue" json:"status_value,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"varint,2,opt,name=value,enum=api.SelectionStatus"`
}

func (m *SetLockingStatusRequest) Reset()                    { *m = SetLockingStatusRequest{} }
func (m *SetLockingStatusRequest) String() string            { return proto.CompactTextString(m) }
func (*SetLockingStatusRequest) ProtoMessage()               {}
func (*SetLockingStatusRequest) Descriptor() ([]byte, []int) { return fileDescriptor15, []int{0} }

func (m *SetLockingStatusRequest) GetStatusValue() map[string]api.SelectionStatus {
	if m != nil {
		return m.StatusValue
	}
	return nil
}

type OverrideSelectionStatusRequest struct {
	IsLive bool `protobuf:"varint,1,opt,name=is_live,json=isLive" json:"is_live,omitempty"`
	// lower cased provider name
	Provider string `protobuf:"bytes,2,opt,name=provider" json:"provider,omitempty"`
}

func (m *OverrideSelectionStatusRequest) Reset()                    { *m = OverrideSelectionStatusRequest{} }
func (m *OverrideSelectionStatusRequest) String() string            { return proto.CompactTextString(m) }
func (*OverrideSelectionStatusRequest) ProtoMessage()               {}
func (*OverrideSelectionStatusRequest) Descriptor() ([]byte, []int) { return fileDescriptor15, []int{1} }

func (m *OverrideSelectionStatusRequest) GetIsLive() bool {
	if m != nil {
		return m.IsLive
	}
	return false
}

func (m *OverrideSelectionStatusRequest) GetProvider() string {
	if m != nil {
		return m.Provider
	}
	return ""
}

type OverrideSelectionStatusReply struct {
	Value api.SelectionStatus `protobuf:"varint,1,opt,name=value,enum=api.SelectionStatus" json:"value,omitempty"`
}

func (m *OverrideSelectionStatusReply) Reset()                    { *m = OverrideSelectionStatusReply{} }
func (m *OverrideSelectionStatusReply) String() string            { return proto.CompactTextString(m) }
func (*OverrideSelectionStatusReply) ProtoMessage()               {}
func (*OverrideSelectionStatusReply) Descriptor() ([]byte, []int) { return fileDescriptor15, []int{2} }

func (m *OverrideSelectionStatusReply) GetValue() api.SelectionStatus {
	if m != nil {
		return m.Value
	}
	return api.SelectionStatus_DISABLED
}

type FullLockingStatusReply struct {
	// Provider Updated Locking Status
	//
	// Status for provider or admin updated selections: ENABLED or TEMPORARY_DISABLED,
	// It can never use any other enum
	ProviderUpdatedLockingStatus *LockingStatus `protobuf:"bytes,1,opt,name=provider_updated_locking_status,json=providerUpdatedLockingStatus" json:"provider_updated_locking_status,omitempty"`
	// Admin Updated Locking Status
	//
	// Status for provider or admin updated selections: ENABLED or TEMPORARY_DISABLED,
	// It can never use any other enum
	AdminUpdatedLockingStatus *LockingStatus `protobuf:"bytes,2,opt,name=admin_updated_locking_status,json=adminUpdatedLockingStatus" json:"admin_updated_locking_status,omitempty"`
}

func (m *FullLockingStatusReply) Reset()                    { *m = FullLockingStatusReply{} }
func (m *FullLockingStatusReply) String() string            { return proto.CompactTextString(m) }
func (*FullLockingStatusReply) ProtoMessage()               {}
func (*FullLockingStatusReply) Descriptor() ([]byte, []int) { return fileDescriptor15, []int{3} }

func (m *FullLockingStatusReply) GetProviderUpdatedLockingStatus() *LockingStatus {
	if m != nil {
		return m.ProviderUpdatedLockingStatus
	}
	return nil
}

func (m *FullLockingStatusReply) GetAdminUpdatedLockingStatus() *LockingStatus {
	if m != nil {
		return m.AdminUpdatedLockingStatus
	}
	return nil
}

type LockingStatus struct {
	// value as map
	//
	// Status for provider or admin updated selections: ENABLED or TEMPORARY_DISABLED,
	// It can never use any other enum
	Value map[string]api.SelectionStatus `protobuf:"bytes,1,rep,name=value" json:"value,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"varint,2,opt,name=value,enum=api.SelectionStatus"`
}

func (m *LockingStatus) Reset()                    { *m = LockingStatus{} }
func (m *LockingStatus) String() string            { return proto.CompactTextString(m) }
func (*LockingStatus) ProtoMessage()               {}
func (*LockingStatus) Descriptor() ([]byte, []int) { return fileDescriptor15, []int{4} }

func (m *LockingStatus) GetValue() map[string]api.SelectionStatus {
	if m != nil {
		return m.Value
	}
	return nil
}

type KeepAliveRequest struct {
	Key string `protobuf:"bytes,1,opt,name=key" json:"key,omitempty"`
}

func (m *KeepAliveRequest) Reset()                    { *m = KeepAliveRequest{} }
func (m *KeepAliveRequest) String() string            { return proto.CompactTextString(m) }
func (*KeepAliveRequest) ProtoMessage()               {}
func (*KeepAliveRequest) Descriptor() ([]byte, []int) { return fileDescriptor15, []int{5} }

func (m *KeepAliveRequest) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func init() {
	proto.RegisterType((*SetLockingStatusRequest)(nil), "internalrpc.SetLockingStatusRequest")
	proto.RegisterType((*OverrideSelectionStatusRequest)(nil), "internalrpc.OverrideSelectionStatusRequest")
	proto.RegisterType((*OverrideSelectionStatusReply)(nil), "internalrpc.OverrideSelectionStatusReply")
	proto.RegisterType((*FullLockingStatusReply)(nil), "internalrpc.FullLockingStatusReply")
	proto.RegisterType((*LockingStatus)(nil), "internalrpc.LockingStatus")
	proto.RegisterType((*KeepAliveRequest)(nil), "internalrpc.KeepAliveRequest")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for SportsbookMonitor service

type SportsbookMonitorClient interface {
	// Get Status of selection according to all locking status
	//
	// For selection in API and place bet checking
	GetOverrideSelectionStatus(ctx context.Context, in *OverrideSelectionStatusRequest, opts ...grpc.CallOption) (*OverrideSelectionStatusReply, error)
	// Get Status of Locking for Provider and Manual Override
	//
	// No input required
	GetFullLockingStatus(ctx context.Context, in *google_protobuf1.Empty, opts ...grpc.CallOption) (*FullLockingStatusReply, error)
	// Set Status of Locking for Manual Override
	//
	// Status_value mapping input should be:
	// from ["betradar_lcoo", "betradar_live", "pinnacle", "prematch", "live", "global"]
	// to ENABLED or TEMPORARY_DISABLED
	SetLockingStatus(ctx context.Context, in *SetLockingStatusRequest, opts ...grpc.CallOption) (*google_protobuf1.Empty, error)
	KeepAlive(ctx context.Context, opts ...grpc.CallOption) (SportsbookMonitor_KeepAliveClient, error)
}

type sportsbookMonitorClient struct {
	cc *grpc.ClientConn
}

func NewSportsbookMonitorClient(cc *grpc.ClientConn) SportsbookMonitorClient {
	return &sportsbookMonitorClient{cc}
}

func (c *sportsbookMonitorClient) GetOverrideSelectionStatus(ctx context.Context, in *OverrideSelectionStatusRequest, opts ...grpc.CallOption) (*OverrideSelectionStatusReply, error) {
	out := new(OverrideSelectionStatusReply)
	err := grpc.Invoke(ctx, "/internalrpc.SportsbookMonitor/GetOverrideSelectionStatus", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sportsbookMonitorClient) GetFullLockingStatus(ctx context.Context, in *google_protobuf1.Empty, opts ...grpc.CallOption) (*FullLockingStatusReply, error) {
	out := new(FullLockingStatusReply)
	err := grpc.Invoke(ctx, "/internalrpc.SportsbookMonitor/GetFullLockingStatus", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sportsbookMonitorClient) SetLockingStatus(ctx context.Context, in *SetLockingStatusRequest, opts ...grpc.CallOption) (*google_protobuf1.Empty, error) {
	out := new(google_protobuf1.Empty)
	err := grpc.Invoke(ctx, "/internalrpc.SportsbookMonitor/SetLockingStatus", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sportsbookMonitorClient) KeepAlive(ctx context.Context, opts ...grpc.CallOption) (SportsbookMonitor_KeepAliveClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_SportsbookMonitor_serviceDesc.Streams[0], c.cc, "/internalrpc.SportsbookMonitor/KeepAlive", opts...)
	if err != nil {
		return nil, err
	}
	x := &sportsbookMonitorKeepAliveClient{stream}
	return x, nil
}

type SportsbookMonitor_KeepAliveClient interface {
	Send(*KeepAliveRequest) error
	CloseAndRecv() (*google_protobuf1.Empty, error)
	grpc.ClientStream
}

type sportsbookMonitorKeepAliveClient struct {
	grpc.ClientStream
}

func (x *sportsbookMonitorKeepAliveClient) Send(m *KeepAliveRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *sportsbookMonitorKeepAliveClient) CloseAndRecv() (*google_protobuf1.Empty, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(google_protobuf1.Empty)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for SportsbookMonitor service

type SportsbookMonitorServer interface {
	// Get Status of selection according to all locking status
	//
	// For selection in API and place bet checking
	GetOverrideSelectionStatus(context.Context, *OverrideSelectionStatusRequest) (*OverrideSelectionStatusReply, error)
	// Get Status of Locking for Provider and Manual Override
	//
	// No input required
	GetFullLockingStatus(context.Context, *google_protobuf1.Empty) (*FullLockingStatusReply, error)
	// Set Status of Locking for Manual Override
	//
	// Status_value mapping input should be:
	// from ["betradar_lcoo", "betradar_live", "pinnacle", "prematch", "live", "global"]
	// to ENABLED or TEMPORARY_DISABLED
	SetLockingStatus(context.Context, *SetLockingStatusRequest) (*google_protobuf1.Empty, error)
	KeepAlive(SportsbookMonitor_KeepAliveServer) error
}

func RegisterSportsbookMonitorServer(s *grpc.Server, srv SportsbookMonitorServer) {
	s.RegisterService(&_SportsbookMonitor_serviceDesc, srv)
}

func _SportsbookMonitor_GetOverrideSelectionStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OverrideSelectionStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SportsbookMonitorServer).GetOverrideSelectionStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/internalrpc.SportsbookMonitor/GetOverrideSelectionStatus",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SportsbookMonitorServer).GetOverrideSelectionStatus(ctx, req.(*OverrideSelectionStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SportsbookMonitor_GetFullLockingStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(google_protobuf1.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SportsbookMonitorServer).GetFullLockingStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/internalrpc.SportsbookMonitor/GetFullLockingStatus",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SportsbookMonitorServer).GetFullLockingStatus(ctx, req.(*google_protobuf1.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _SportsbookMonitor_SetLockingStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetLockingStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SportsbookMonitorServer).SetLockingStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/internalrpc.SportsbookMonitor/SetLockingStatus",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SportsbookMonitorServer).SetLockingStatus(ctx, req.(*SetLockingStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SportsbookMonitor_KeepAlive_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(SportsbookMonitorServer).KeepAlive(&sportsbookMonitorKeepAliveServer{stream})
}

type SportsbookMonitor_KeepAliveServer interface {
	SendAndClose(*google_protobuf1.Empty) error
	Recv() (*KeepAliveRequest, error)
	grpc.ServerStream
}

type sportsbookMonitorKeepAliveServer struct {
	grpc.ServerStream
}

func (x *sportsbookMonitorKeepAliveServer) SendAndClose(m *google_protobuf1.Empty) error {
	return x.ServerStream.SendMsg(m)
}

func (x *sportsbookMonitorKeepAliveServer) Recv() (*KeepAliveRequest, error) {
	m := new(KeepAliveRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _SportsbookMonitor_serviceDesc = grpc.ServiceDesc{
	ServiceName: "internalrpc.SportsbookMonitor",
	HandlerType: (*SportsbookMonitorServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetOverrideSelectionStatus",
			Handler:    _SportsbookMonitor_GetOverrideSelectionStatus_Handler,
		},
		{
			MethodName: "GetFullLockingStatus",
			Handler:    _SportsbookMonitor_GetFullLockingStatus_Handler,
		},
		{
			MethodName: "SetLockingStatus",
			Handler:    _SportsbookMonitor_SetLockingStatus_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "KeepAlive",
			Handler:       _SportsbookMonitor_KeepAlive_Handler,
			ClientStreams: true,
		},
	},
	Metadata: "internalrpc/sportsbook_monitor.proto",
}

func init() { proto.RegisterFile("internalrpc/sportsbook_monitor.proto", fileDescriptor15) }

var fileDescriptor15 = []byte{
	// 514 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x93, 0xd1, 0x6e, 0xd3, 0x30,
	0x14, 0x86, 0x9b, 0x4e, 0x8c, 0xf5, 0x14, 0x50, 0xb1, 0xa6, 0x6d, 0x64, 0x1d, 0xab, 0x42, 0x91,
	0x0a, 0x48, 0xae, 0x54, 0x84, 0x84, 0xe0, 0x0a, 0xa4, 0x6d, 0x12, 0x0c, 0x90, 0x52, 0x8a, 0x90,
	0xb8, 0x88, 0xdc, 0xf6, 0x50, 0x59, 0x75, 0x63, 0xe3, 0x38, 0x91, 0xfa, 0x2e, 0xbc, 0x10, 0x6f,
	0xc0, 0xd3, 0x20, 0x94, 0x78, 0x6d, 0x93, 0x6c, 0x61, 0xbb, 0xe0, 0x2e, 0xb1, 0xff, 0xf3, 0xfd,
	0xf6, 0xf1, 0x7f, 0xa0, 0xcb, 0x43, 0x83, 0x3a, 0x64, 0x42, 0xab, 0x49, 0x3f, 0x52, 0x52, 0x9b,
	0x68, 0x2c, 0xe5, 0x3c, 0x58, 0xc8, 0x90, 0x1b, 0xa9, 0xa9, 0xd2, 0xd2, 0x48, 0xd2, 0xcc, 0xa9,
	0xdc, 0xc3, 0x99, 0x94, 0x33, 0x81, 0xfd, 0x6c, 0x6b, 0x1c, 0x7f, 0xef, 0xe3, 0x42, 0x99, 0xa5,
	0x55, 0xba, 0xc7, 0x1b, 0x46, 0x9f, 0x29, 0x9e, 0x43, 0x5a, 0x81, 0xf7, 0xcb, 0x81, 0xfd, 0x21,
	0x9a, 0x73, 0x39, 0x99, 0xf3, 0x70, 0x36, 0x34, 0xcc, 0xc4, 0x91, 0x8f, 0x3f, 0x62, 0x8c, 0x0c,
	0xf9, 0x0a, 0x77, 0xa2, 0x6c, 0x21, 0x48, 0x98, 0x88, 0xf1, 0xc0, 0xe9, 0x6c, 0xf5, 0x9a, 0x83,
	0x17, 0x34, 0xe7, 0x4e, 0x2b, 0x6a, 0xa9, 0xfd, 0xfb, 0x92, 0xd6, 0x9d, 0x84, 0x46, 0x2f, 0xfd,
	0x66, 0xb4, 0x59, 0x71, 0x3f, 0x43, 0xab, 0x2c, 0x20, 0x2d, 0xd8, 0x9a, 0xe3, 0xf2, 0xc0, 0xe9,
	0x38, 0xbd, 0x86, 0x9f, 0x7e, 0x92, 0xa7, 0x70, 0xcb, 0x1a, 0xd7, 0x3b, 0x4e, 0xef, 0xde, 0x60,
	0x97, 0x32, 0xc5, 0xe9, 0x10, 0x05, 0x4e, 0x0c, 0x97, 0xe1, 0x85, 0x9f, 0x95, 0xbc, 0xaa, 0xbf,
	0x74, 0xbc, 0x11, 0x3c, 0xfc, 0x94, 0xa0, 0xd6, 0x7c, 0x8a, 0x65, 0xd5, 0xc5, 0x8d, 0xf6, 0xe1,
	0x36, 0x8f, 0x02, 0xc1, 0x13, 0xcc, 0x7c, 0x76, 0xfc, 0x6d, 0x1e, 0x9d, 0xf3, 0x04, 0x89, 0x0b,
	0x3b, 0x4a, 0xcb, 0x84, 0x4f, 0x51, 0x67, 0x6e, 0x0d, 0x7f, 0xfd, 0xef, 0xbd, 0x83, 0x76, 0x25,
	0x56, 0x89, 0xdc, 0x31, 0x9d, 0x6b, 0x8f, 0xe9, 0xfd, 0x76, 0x60, 0xef, 0x34, 0x16, 0xa2, 0xd4,
	0xb3, 0x14, 0xc3, 0xe0, 0x78, 0x65, 0x19, 0xc4, 0x6a, 0xca, 0x0c, 0x4e, 0x03, 0x61, 0x65, 0x81,
	0xed, 0x5d, 0x66, 0xd0, 0x1c, 0xb8, 0x85, 0x07, 0x28, 0x92, 0xda, 0x2b, 0xc4, 0xc8, 0x12, 0x0a,
	0xbb, 0xe4, 0x1b, 0xb4, 0xd9, 0x74, 0xc1, 0xc3, 0x2a, 0x7e, 0xfd, 0x5a, 0xfe, 0x83, 0xac, 0xfe,
	0x2a, 0xb8, 0xf7, 0xd3, 0x81, 0xbb, 0x45, 0xbb, 0xd7, 0x9b, 0xc6, 0xa4, 0xc1, 0x79, 0x5c, 0xcd,
	0xa5, 0xb9, 0xa0, 0xd8, 0x1a, 0xf7, 0x23, 0xc0, 0x7f, 0x0d, 0x47, 0x17, 0x5a, 0xef, 0x11, 0xd5,
	0x9b, 0xf4, 0xf1, 0x57, 0x71, 0xb8, 0x44, 0x1d, 0xfc, 0xa9, 0xc3, 0xfd, 0xe1, 0x7a, 0x46, 0x3e,
	0xd8, 0xa9, 0x23, 0x09, 0xb8, 0x67, 0x68, 0x2a, 0x42, 0x40, 0x9e, 0x15, 0xee, 0xf5, 0xef, 0x04,
	0xba, 0x4f, 0x6e, 0x26, 0x56, 0x62, 0xe9, 0xd5, 0xc8, 0x08, 0x76, 0xcf, 0xd0, 0x5c, 0xca, 0x0b,
	0xd9, 0xa3, 0x76, 0xe6, 0xe9, 0x6a, 0xe6, 0xe9, 0x49, 0x3a, 0xf3, 0xee, 0xa3, 0x02, 0xfc, 0xea,
	0x9c, 0x79, 0x35, 0xe2, 0x43, 0xab, 0x3c, 0xb6, 0xa4, 0x7b, 0x93, 0xa9, 0x76, 0x2b, 0x8c, 0xbd,
	0x1a, 0x39, 0x85, 0xc6, 0xba, 0xbd, 0xe4, 0xa8, 0x00, 0x2b, 0xb7, 0xbd, 0x9a, 0xd2, 0x73, 0xde,
	0x1e, 0xc1, 0xe1, 0x44, 0x2e, 0xe8, 0x98, 0x9b, 0x19, 0x5b, 0xa0, 0x60, 0xe3, 0x28, 0xcf, 0x1a,
	0x6f, 0x67, 0x25, 0xcf, 0xff, 0x06, 0x00, 0x00, 0xff, 0xff, 0xd4, 0xb6, 0x94, 0x65, 0x28, 0x05,
	0x00, 0x00,
}
